\documentclass[a4paper]{article}

\usepackage[swedish]{babel}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{courier}
\usepackage{graphicx}
\usepackage[justification=centering]{caption}
\usepackage{listings}
\usepackage{color}
\usepackage{pdfpages}
\definecolor{mygray}{rgb}{0.5,0.5,0.5}
\lstset{language=C, basicstyle=\footnotesize,
        numbers=left, numberstyle=\tiny\color{mygray}}

\title{Minneshantering}
\date{ID2200 - Laboration 3}
\author{Cecilia Roes \\ Fredrik Hillnertz}

\begin{document}
\includepdf{pre_lab3.pdf}
\maketitle

\section*{Problembeskrivning}
Implementera de metoder som förvaltar systemets minnesresurser nämligen: \texttt{malloc}, \texttt{free} och \texttt{realloc}. I uppgiften ingick också att implementera ett antal olika taktiker för minnesallokering i \texttt{malloc}, såsom first-fit, best-fit och worst-fit. Kraven på implementation är att den skall följa \texttt{ANSI/ISO}-standarden och att inga metoder ska läcka minne.
\\
\\
Utöver detta så ska prestandan evalueras. I testerna ska worst och best case scenarion ingå, samt rimliga användningsfall. Med hjälp av testerna så ska minnesallokeringens prestanda med avseende på minnesutnyttjande och exekveringstid mätas, utvärderas och jämföras med prestandan för biblioteksimplementationen av \texttt{malloc}.

\section*{Programbeskrivning}
\subsection*{Hopslagning av lediga minnesblock }
Det mest logiska är att slå ihop minnes block i metoden free. När free anropas så hittas hålet i free-listan där blocket passar in. Sedan undersöks det om det föregående och/eller det efterföljande blocket i listan ligger brevid varandra i minnet. Isåfall så slås de kontinuerliga blocken ihop till ett. Detta innebär att alla block är så ihopslagna som möjligt när malloc anropas. Free-listan är alltså så kort som det bara går vilket gör malloc mer effektiv då det går snabbare att gå igenom en liten lista.

\subsection*{Förklaring av kod som kompileras om MMAP är definierat}
\lstinputlisting[firstline=66, lastline=74, firstnumber=66]{malloc.c}
Variabeln \texttt{\_\_endHeap} är en pekare som pekar på slutet av processens minne. \texttt{\_\_endHeap} iniatiliseras med värdet av anropet \texttt{sbrk(0)} som returnerar en pekare till slutet av processens minne.

\lstinputlisting[firstline=77, lastline=92, firstnumber=77, breaklines=true]{malloc.c}
I funktionen \texttt{morecore} ber man systemet om mer minne. Om \texttt{MMAP} är definerat gör detta med ett anrop till \texttt{mmap} som skapar en ny mappning i det virituella minnet för den anropande processen. \texttt{mmap} tar sex stycken parametrar. 1: En startaddress där minnet ska börja mappas. Här skickas \texttt{\_\_endHeap} in så att minnet blir kontinuerligt. 2: Hur mycket minne som ska mappas i bytes. Detta värde är en multipel av systemets page size som hittas med \texttt{getpagesize()}. 3: Flaggor som sätter minnesskyddet för det mappade minnet. Flaggorna som vi använder är \texttt{PROT\_READ} och \texttt{PROT\_WRITE} så att minnet kan skrivas och läsas. 4: Mer flaggor. De som används är \texttt{MAP\_SHARED} vilket innebär att mappningen är synlig för andra processer, och \texttt{MAP\_ANONYMOUS} som gör att mappningen inte "backas up" av en fil, minnet som allokeras initieras till noll och de två resterande argumenten ignoreras. Efter att \texttt{mmap} har körts flyttas \texttt{\_\_endHeap} fram med lika många bytes som allokerades.

På rad 88 beräknas det antal sidor som kommer allokeras, värt att notera är att antalet är beroende av den begärda minnesstorleken (dock minst \texttt{NALLOC}) och storleken av \texttt{Header}.
\\
\subsubsection*{I koden initialiseras \texttt{\_\_endHeap} mha \texttt{sbrk(2)} vilket inte är så snyggt och inte skulle fungera på system där \texttt{sbrk(2)} inte stöds. Vad händer om du tar bort dessa initialiseringar (två \texttt{if}-satser)? Vad skulle \texttt{\_\_endHeap} då representera?}
Vid första anropet kommer \texttt{\_\_endHeap} att peka på \texttt{NULL} vilket gör att systemet väljer vart minnet ska mappas när \texttt{mmap} anropas (se nästa fråga). Vid efterföljande anrop till \texttt{mmap} kommer \texttt{\_\_endHeap} att peka ut en address. Systemet tar dock bara addresspekaren som ett förslag. Om det inte går att mappa in minne där så väljer systemet än en gång vart minnet ska mappas. Ibland hamnar mappningen där \texttt{\_\_endHeap} pekar, ibland inte. Resultatet blir att minnet blir segmenterat. \texttt{\_\_endHeap} visar nu inte längre vart i det virtuella minnet programmet är utan den blir en slags räknare som representerar hur mycket minnet som har mappats med \texttt{mmap}.

\subsubsection*{Vad händer om man skickar \texttt{NULL} som första parameter till \texttt{mmap(2)}? Vad fungerar/fungerar inte? Vet man då var minnet reserveras?}
Då bestämmer kärnan vart minnet ska mappas in. När vi har testat har alla test gått igenom. Risken finns dock att \texttt{malloc} blir mindre effektivt om kärnan allokerar minnet väldigt utspritt. Då kommer olika block inte kunna mergas ihop vilket leder till att free-listan blir längre, och det gör att det tar längre tid att gå igenom den.

\subsubsection*{Vad händer om man byter ut/tar bort flaggan \texttt{MAP\_SHARED} i anropet till \texttt{mmap(2)}?}
Flaggorna \texttt{MAP\_SHARED} och \texttt{MAP\_PRIVATE} styr huruvida uppdateringar av mappningen är synlig för andra processer eller inte, det avgör också om uppdateringar görs på den underliggande filen. En av flaggorna måste specificeras. Byter man till \texttt{MAP\_PRIVATE} kommer en privat copy-on-write mappning skapas, uppdateringar syns inte för andra processer och skrivs inte till fil.

\section*{Utvärdering}
\subsection*{Analys}
Nedan följer kommentarer och slutsatser från att ha studerat källkoden. Dessa stämmer inte nödvändigtvis med programmets faktiska prestationer.

\subsubsection*{Minnesåtgång}
Alla de implementerade allokeringsmetoderna har samma bästa och värsta fall, sedan är de olika bra på att hantera andra allokeringsbeteenden/mönster.
\\
I bästa fall allokeras precis så mycket minne som får plats i det lediga blocket (antingen genom ett eller flera anrop, vid flera anrop kommer bakre änden successivt allokeras).
\\
I värsta fall allokeras så mycket minne att påföljande minnesallokeringar precis inte får plats, detta sker då man allokerar hälften av ett tillgängligt block (eftersom headern tar upp en bit minne utöver det man vill allokera så får nästa allokering inte plats).

\subsubsection*{Tidsåtgång}
Tidskomplexiteten i värsta fall är samma oavsett allokeringsmetod, om inget tillräckligt stort minne hittas gås hela listan igenom. Däremot kommer best- och worst-fit gå igenom hela listan varje gång (undantaget en liten optimering av best-fit som gör att den slutar vid perfect-fit) medan first-fit slutar då ett tillräckligt stort block hittats.

Bästa fallet för tidsåtgång sammanfaller med bästa fallet för minnesåtgång. Om man helt fyller upp alla minnesblock så kommer listan bara innehålla 1 element, och att leta blir en konstant operation. Däremot måste man köra \texttt{mmap}, vilket är en tung operation, varje gång ett block fylls upp, så att fylla det med små bitar är det bästa.

Även värsta fallet är samma som för minnesåtgång. När blocken aldrig fylls upp innebär det att listan växer för varje ny allokering, listan får alltså samma längd som antalet allokeringar.

\begin{table}[h]
\centering
\caption{Resursåtgång i värsta och bästa fall \\ m = summa av begärt minne, n = antal malloc-anrop}
\scalebox{1.2}{
  \begin{tabular}{|l|c|c|}
    \hline
    & \multicolumn{2}{c|}{Åtgång} \\
    \hline
    Fall & Minne & Tid \\
    \hline
    Bästa & m + headers & 1 \\
    Värsta & 2*m & n \\
    \hline
  \end{tabular}
}
\end{table}

\subsection*{Evaluering}
Som diskuterats ovan har vi alltså ett tydligt bästa och värsta fall, och eftersom vi har tillgång till källkoden vet vi vad lämpliga parametrar till malloc är för att undersöka dessa.

I testet för värsta fallet anropar vi \texttt{malloc(512*sizeof(Header))}, vilket är halva storleken av det minsta block som skapas av \texttt{morecore}.

I testet för bästa fallet anropar vi \texttt{malloc(1023*sizeof(Header))}, vilket är storleken av det minsta block som skapas av \texttt{morecore} minus en header. Detta innebär att varje anrop av \texttt{malloc} kommer fylla upp ett nytt block som allokerats av \texttt{morecore}.

Vi har dessutom test för ökande respektive minskande minnesstorlekar och ett test med randomiserade minnesstorlekar för att bättre efterlikna verkligt användande.

\subsection*{Slutsats}
Gör man multipla körningar i samma process (t.ex. genom att loopa anropet av ett testfall flera gånger) kommer minnet som man avallokerat genom anrop till \texttt{free} finnas tillgängligt i listan, så körningar efter den första går väldigt snabbt då inget mer minne behöver allokeras utan allt får plats.
Detta gör det svårt att få något medelvärde på körningstid eller minnesanvändning, vilket i sin tur gör det svårt att uppskatta felmarginaler.

\section*{Filkatalog}
Alla filer som är associerade med denna lab går att finna i:\\
\texttt{frhi@shell.it.kth.se:/Kurser/OS/lab3/}
\\
Filer:
\begin{description}
\item[malloc.c] källkoden
\item[eval.c] kod för prestanda evalueringen
\item[RUN\_EVAL] script för att kompilera och köra evalueringen
\item[Makefile] makefil för att bygga programmet
\item[lab3-rapport.pdf] denna rapport i pdf-format
%\item[exampleRuns.txt] exempel på körningar av programmet
\end{description}

\section*{Utskrift med kompileringskommandon}
%\lstinputlisting[basicstyle=\footnotesize, breaklines]{commands.txt}

\section*{Källkod}
\subsection*{Ur malloc.c}
\lstinputlisting[xleftmargin=-0.5in, firstline=144, lastline=236, firstnumber=144]{malloc.c}

\subsection*{eval.c}
\lstinputlisting[xleftmargin=-0.5in]{eval.c}

\section*{Verksamhetsberättelse och synpunkter}
Tidsåtgång: ca h per person.

\end{document}

