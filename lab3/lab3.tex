\documentclass[a4paper]{article}

\usepackage[swedish]{babel}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{courier}
\usepackage{listings}
\usepackage{pdfpages}

\title{Minneshantering}
\date{ID2200 - Laboration 3}
\author{Cecilia Roes \\ Fredrik Hillnertz}

\begin{document}
\includepdf{pre_lab3.pdf}
\maketitle

\section*{Problembeskrivning}
Implementera de metoder som förvaltar systemets minnesresurser nämligen: malloc, free och realloc. I uppgiften ingick också att implementera ett antal olika taktiker för minnesallokering i malloc, såsom first-fit, best-fit och worst-fit. Kraven på implementation är att den skall följa ANSI/ISO-standarden och att inga metoder ska läcka minne.
\\
\\
Utöver detta så ska prestandan evalueras. I testerna ska worst och best case scenarion ingå, samt rimliga användningsfall. Med hjälp av testerna så ska minnesallokeringens prestanda med avseende på minnesutnyttjande och exekveringstid mätas, utvärderas och jämföras med prestandan för biblioteksimplementationen av malloc.

\section*{Programbeskrivning}
% Skriv om metod för hopslagning av minnesblock (2.2 punkt 6) La till en sektion för mergemetoden
% Redan impl i free.

\subsection*{Förklaring av kod som kompileras om MMAP är definierat}
%static void * __endHeap = 0;

%void * endHeap(void)
%{
%  if(__endHeap == 0) __endHeap = sbrk(0);
%  return __endHeap;
%}

Variabeln \_\_endHeap är en pekare som pekar på slutet av processens minne. \_\_endHeap iniatiliseras med värdet av anropet sbrk(0) som returnerar en pekare till slutet av processens minne.

%
%unsigned noPages;
%if(__endHeap == 0) __endHeap = sbrk(0);

%noPages = ((nu*sizeof(Header))-1)/getpagesize() + 1;
%cp = mmap(__endHeap, noPages*getpagesize(), PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANONYMOUS, -1, 0);
%nu = (noPages*getpagesize())/sizeof(Header);
%__endHeap += noPages*getpagesize();

I funktionen morecore ber man systemet om mer minne. Om MMAP är definerat gör detta med ett anrop till mmap som skapar en ny mappning i det virituella minnet för den anropande processen. mmap tar sex stycken parametrar. 1: En startaddress där minnet ska börja mappas. Här skickas \_\_endHeap in så att minnet blir kontinuerligt. 2: Hur mycket minne som ska mappas i bytes. Detta värde bör vara en multipel av systemets page size som hittas med getpagesize(). 3: Flaggor som sätter minnesskyddet för det mappade minnet. Flaggorna som vi använder är PROT\_READ och PROT\_WRITE så att minnet kan skrivas och läsas. 4: Mer flaggor. De som används är MAP\_SHARED vilket innebär att mappningen är synlig för andra processer, och MAP\_ANONYMOUS som gör att mappningen inte "backas up" av en fil, minnet som allokeras initieras till noll och de två resterande argumenten ignoreras. Efter att mmap har körts flyttas \_\_endHeap fram med lika många bytes som allokerades.

\subsubsection*{I koden initialiseras \texttt{\_\_endHeap} mha \texttt{sbrk(2)} vilket inte är så snyggt och inte skulle fungera på system där \texttt{sbrk(2)} inte stöds. Vad händer om du tar bort dessa initialiseringar (två \texttt{if}-satser)? Vad skulle \texttt{\_\_endHeap} då representera?}
% Alla test förutom första går igenom om man inte initialiserar endHeap med sbrk(0)
Vid första anropet kommer \_\_endHeap att peka på nil vilket gör att systemet väljer vart minnet ska mappas när mmap anropas (se nästa fråga). Vid efterföljande anrop till mmap kommer \_\_endHeap att peka ut en address. Systemet tar dock bara addresspekaren som ett förslag. Om det inte går att mappa in minne där så väljer systemet än en gång vart minnet ska mappas. Ibland hamnar mappningen där \_\_endHeap pekar, ibland inte. Resultatet blir att minnet blir segmenterat. \_\_endHeap visar nu inte längre vart i det virtuella minnet programmet är utan den blir en slags räknare som representerar hur mycket minnet som har mappats med mmap.

\subsubsection*{Vad händer om man skickar \texttt{NULL} som första parameter till \texttt{mmap(2)}? Vad fungerar/fungerar inte? Vet man då var minnet reserveras?}
Då bestämmer kärnan vart minnet ska mappas in. När vi har testat har alla test gått igenom. Risken finns dock att malloc blir mindre effektivt om kärnan allokerar minnet väldigt utspritt. Då kommer olika block inte kunna mergas ihop vilket leder till att freelistan blir längre, och det gör att det tar längre tid att gå igenom den.

%worst case scenario?

\subsubsection*{Hopslagning av lediga minnesblock }
Det mest logiska är att slå ihop minnes block i metoden free. När free anropas så hittas hålet i free-listan där blocket passar in. Sedan undersöks det om det föregående och/eller det efterföljande blocket i listan ligger brevid varandra i minnet. Isåfall så slås de kontinuerliga blocken ihop till ett. Detta innebär att alla block är så ihopslagna som möjligt när malloc anropas. Free-listan är alltså så kort som det bara går vilket gör malloc mer effektiv då det går snabbare att gå igenom en liten lista.

\subsubsection*{Vad händer om man byter ut/tar bort flaggan \texttt{MAP\_SHARED} i anropet till \texttt{mmap(2)}?} %inte helt hundra på den här
I anropet till mmap så måste antingen MAP\_SHARED eller MAP\_PRIVET sättas. MAP\_PRIVATE innebär att ändringar till det mappade området inte är synligt för andra processer. Detta gäller dock mest bara om man har en fil som backar up mappningen. Andra processer kan fortfarande komma åt minnet med en pekare. Allt fungerar fortfarande om MAP\_PRIVATE används.

\section*{Utvärdering}
Bästafallet testas av programmet testBestCase. Den allokerar ett antal heltal och longs som anges av den första inparametern. Sedan frigörs allt som allokerats. 

Att traversera free-listan är den största flaskhalsen i vår implementering av malloc. Men i detta test frigörs allting på slutet, alltså växer aldrig free-listan. Därför har vi i bästafallet ungefär samma prestanda som biblioteksimplementationerna av malloc.

Värstafallet testas av programmet testalternate. Först allokeras en array med heltal. Därefter frigörs varannat heltal. Blocken som frigörs kommer inte att vara alignade så free kan inte slå ihop dom utan de hamnar i free-listan istället. Sedan allokeras en array med longs. Tillsist frigörs allt.

Testalternate utnyttjar svagheten att malloc måste gå igenom free-listan tills ett block av lämplig storlek hittas. Free-listan blir under körningen väldigt lång när varannat block frigörs. När vi testade använde vi arrays med storleken 100000. Under testet kommer alltså free-listan bestå av 50000 block när hela arrayen med 100000 longs ska allokeras. Malloc kommer då att gå igenom hela free-listan för varje long som allokeras (de får inte plats i blocken där integerna har varit). Det tar väldigt lång tid. Eftersom vi inte sköter sådana fall på ett smart sätt så blir prestandan väldigt mycket sämre än biblioteksimplementationerna av malloc. 


% Lägg till -O4 till kompileringen för maximal optimering

% Liten, stor och blandad storlek på data, mycket och lite data (en/flera allokeringar).
% Repetera körningarna, använd någon form av snittvärden, medelvärde och/eller medianvärde.

\subsection*{First fit}

\subsection*{Best fit}

\section*{Filkatalog}
Alla filer som är associerade med denna lab går att finna i:\\
\texttt{frhi@shell.it.kth.se:/Kurser/OS/lab3/}
\\
Filer:
\begin{description}
\item[malloc.c] källkoden
\item[Makefile] makefil för att bygga programmet
\item[lab3-rapport.pdf] denna rapport i pdf-format
%\item[exampleRuns.txt] exempel på körningar av programmet
\end{description}

\section*{Utskrift med kompileringskommandon}
%\lstinputlisting[basicstyle=\footnotesize, breaklines]{commands.txt}

\section*{Källkod}
%\lstinputlisting[language=C, xleftmargin=-1in, basicstyle=\footnotesize]{smallshell.c}

\section*{Verksamhetsberättelse och synpunkter}
Tidsåtgång: ca h per person.

\end{document}

